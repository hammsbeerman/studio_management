<div class="modal-content">
  <div class="modal-header">
    <h5 class="modal-title">Apply Payment #{{ payment.id }} — {{ customer.company_name }}</h5>
    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
  </div>

  <div class="modal-body">
    {% if error %}<div class="alert alert-danger">{{ error }}</div>{% endif %}

    <div class="text-muted mb-2">
      Amount: <strong>{{ payment.amount|floatformat:2 }}</strong>
      • Available: <strong id="pay-available">{{ payment.available|default_if_none:0|floatformat:2 }}</strong>
      {% if payment.check_number %} • Check: <strong>#{{ payment.check_number }}</strong>{% endif %}
    </div>

    <form hx-post="{% url 'finance:apply_unapplied_payment_modal' payment_id=payment.id %}"
          hx-headers='{"X-CSRFToken":"{{ csrf_token }}"}'
          hx-swap="none">

      <div class="row g-2 mb-3">
        <div class="col-md-4">
          <label class="form-label">Date</label>
          <input class="form-control" type="date" name="date" value="{{ default_date|date:'Y-m-d' }}">
        </div>

        <div class="col-md-4">
          <label class="form-label">Amount to apply</label>
          <input class="form-control" type="number" step="0.01" min="0"
                 name="amount" id="apply-amount"
                 value="">
          <div class="form-text">
            Auto-fills from selected invoices; you can lower it for underpayment.
          </div>
        </div>

        <div class="col-md-4">
          <label class="form-label">Selected total</label>
          <input class="form-control" type="text" id="selected-total" value="0.00" readonly>
        </div>
      </div>

      <div class="table-responsive">
        <table class="table table-sm align-middle mb-0">
          <thead>
            <tr>
              <th style="width:1%; white-space:nowrap;">
                <input class="form-check-input" type="checkbox" id="check-all">
              </th>
              <th>Workorder</th>
              <th>Description</th>
              <th class="text-end">Open</th>
            </tr>
          </thead>
          <tbody>
            {% for wo in workorders %}
              <tr>
                <td>
                  <input class="form-check-input wo-check"
                         type="checkbox"
                         name="workorders"
                         value="{{ wo.id }}"
                         data-open="{{ wo.open_balance|default_if_none:0 }}">
                </td>
                <td style="white-space:nowrap;">WO {{ wo.workorder }}</td>
                <td>{{ wo.description|default:"—" }}</td>
                <td class="text-end">{{ wo.open_balance|floatformat:2 }}</td>
              </tr>
            {% empty %}
              <tr><td colspan="4" class="text-muted">No open workorders.</td></tr>
            {% endfor %}
          </tbody>
        </table>
      </div>

      <div class="mt-3 d-flex justify-content-end gap-2">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="submit" class="btn btn-primary">Apply</button>
      </div>
    </form>
  </div>
</div>

<script>
(function () {
  const available = parseFloat((document.getElementById("pay-available")?.textContent || "0").replace(/,/g, "")) || 0;

  const amountInput = document.getElementById("apply-amount");
  const selectedTotalInput = document.getElementById("selected-total");
  const checks = Array.from(document.querySelectorAll(".wo-check"));
  const checkAll = document.getElementById("check-all");

  function sumSelected() {
    let total = 0;
    for (const c of checks) {
      if (!c.checked) continue;
      const open = parseFloat((c.dataset.open || "0").toString().replace(/,/g, "")) || 0;
      total += open;
    }
    return total;
  }

  function updateAutoAmount() {
    const selectedTotal = sumSelected();
    selectedTotalInput.value = selectedTotal.toFixed(2);

    // Only auto-set if user hasn't manually typed something
    if (!amountInput.dataset.userEdited || amountInput.dataset.userEdited !== "1") {
      const auto = Math.min(available, selectedTotal);
      amountInput.value = auto.toFixed(2);
    } else {
      // Clamp manual value to [0, available]
      const cur = parseFloat(amountInput.value || "0") || 0;
      const clamped = Math.max(0, Math.min(available, cur));
      if (clamped !== cur) amountInput.value = clamped.toFixed(2);
    }
  }

  // Mark as user-edited when they type
  amountInput?.addEventListener("input", () => {
    amountInput.dataset.userEdited = "1";
    updateAutoAmount();
  });

  // Check/uncheck handlers
  for (const c of checks) {
    c.addEventListener("change", updateAutoAmount);
  }

  // Check all
  if (checkAll) {
    checkAll.addEventListener("change", () => {
      for (const c of checks) c.checked = checkAll.checked;
      updateAutoAmount();
    });
  }

  // Initial fill
  updateAutoAmount();
})();
</script>